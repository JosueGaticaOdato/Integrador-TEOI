package app;

import nodos.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

parser code {:
  
    private List<String> reglas = new ArrayList<String>();
    private static List<SymbolTableEntry> ts = new ArrayList<SymbolTableEntry>();

    private static String errorMsg;

    public parser(java_cup.runtime.Scanner s, ArrayList<SymbolTableEntry> table) {
        super(s);
        parser.ts = table;
    }

    // Metodo al que se llama automaticamente ante algun error sintactico.
    public void syntax_error(Symbol s){
        errorMsg = "Error en la linea " + (s.right - 1) + ". "
            + s + " no reconocido. valor " + s.value;
    }

    public List<String> getList() {
        return this.reglas;
    }

    public static List<SymbolTableEntry> getTS() {
        return ts;
    }

    public static String getErrorMsg() {
        return errorMsg;
    }

    public void agregarTipo(Object id, Object type) {
        for (SymbolTableEntry entrada : ts) {
            if (entrada.getToken().equals("ID") && entrada.getNombre().equals(id)) {
                entrada.tipo = (String) type;
            }
        }
    }
:}

action code {:
  public String resultado = "";
  public List<NodoSentencia> a ;
  public int contadorPrimos = 0;
:}

terminal OP_ASIGNACION, OP_DECLARACION, OP_SUMA, OP_RESTA, OP_DIVISION, OP_MULTIPLICACION,OP_MENOR, OP_MAYOR, OP_MAYOR_IGUAL, OP_MENOR_IGUAL, OP_DISTINTO, OP_AND, OP_OR, OP_NOT,PARENTESIS_ABRE,  PARENTESIS_CIERRA, LLAVE_ABRE, LLAVE_CIERRA, CORCHETE_ABRE, CORCHETE_CIERRA, PUNTO_COMA, COMA, PUNTO, DOS_PUNTOS, IGUAL, INTEGER, STRING, FLOAT, WHILE, IF, THEN, ELSE, ENDIF, WRITE,DECLARE, ENDDECLARE, PROGRAM,
ENDPROGRAM, CONTAR_PRIMOS;
terminal String ID, CONST_STR, CONST_INTEGER, CONST_DOU, CONST_BIN, OP_IGUAL;

non terminal NodoPrograma programa;
non terminal NodoPrograma miprograma;
non terminal List<NodoSentencia> sentencias;
non terminal NodoSentencia sentencia;
non terminal NodoExpresion expresion, termino, factor; 
non terminal NodoAsignacion asignacion;
non terminal NodoExpresionBooleana condicion,comparacion;
non terminal NodoIf seleccion;
non terminal NodoCiclo iteracion;
non terminal NodoExpresion parametros;

non terminal declaraciones, asignacion_tipos, codigo, declaracion, lista, tipo, miprog, sentWrite, comparador, salida, funcioncontarprimos;

precedence left OP_OR;
precedence left OP_AND;
precedence left OP_NOT;

start with programa;

programa ::= miprograma:s {: 
    reglas.add("Regla N°-1: programa -> miprograma");
    RESULT = s;
    System.out.println("Programa sin declaraciones");
:};
programa ::= declaraciones miprograma {: reglas.add("Regla N°0: programa -> declaraciones miprograma"); :};
programa ::= miprog {: reglas.add("Regla N°1: programa -> miprog "); :};



declaraciones ::= DECLARE declaracion ENDDECLARE {: reglas.add("Regla N°2: declaraciones -> DECLARE declaracion ENDDECLARE "); :};

declaracion ::= declaracion asignacion_tipos {: reglas.add("Regla N°3: declaracion ->  declaracion asignacion_tipos "); :};
declaracion ::= asignacion_tipos {: reglas.add("Regla N°4: declaracion -> asignacion_tipos "); :};

asignacion_tipos ::= CORCHETE_ABRE lista CORCHETE_CIERRA {: reglas.add("Regla N°5: asignacion_tipos ->  CORCHETE_ABRE lista CORCHETE_CIERRA "); :};

lista ::= ID:id COMA lista COMA tipo:type {:
    reglas.add("Regla N°6: lista -> ID COMA lista COMA tipo ");
    RESULT = id;
    agregarTipo(id,type);
:};
lista ::= ID:id CORCHETE_CIERRA OP_DECLARACION CORCHETE_ABRE tipo:type {: 
  reglas.add("Regla N°7: lista -> ID CORCHETE_CIERRA OP_DECLARACION CORCHETE_ABRE tipo ");
  RESULT = id;
  agregarTipo(id,type);
:};


tipo ::= INTEGER:integer  {: 
  reglas.add("Regla N°8: tipo -> INTEGER");
  RESULT = integer;
:};
tipo ::= STRING:string  {:
  reglas.add("Regla N°9: tipo -> STRING");
  RESULT = string;
:};
tipo ::= FLOAT:flotante   {:
  reglas.add("Regla N°10: tipo -> FLOAT");
  RESULT = flotante;
:};




miprograma ::= PROGRAM sentencias:s ENDPROGRAM {: 
    reglas.add("Regla N°11: miprograma -> PROGRAM sentencia ENDPROGRAM");
    RESULT = new NodoPrograma(s);
    System.out.println("Comienzo de programa");
:};
miprog ::= miprog sentWrite {: reglas.add("Regla N°12: miprog -> miprog sentWrite"); :};
sentWrite ::= WRITE CONST_STR {: reglas.add("Regla N°13: sentWrite -> WRITE CONST_STR"); :};


sentencias ::= sentencias:ss sentencia:s {:
                  ss.add(s);
                  RESULT = ss;
                  System.out.println("sentencias sentencia");
               :}
             | sentencia:s {:a = new ArrayList<NodoSentencia>();
                            a.add(s);
                            RESULT = a;
                            System.out.println("sentencia");

               :}
 /* se puede reemplazar la ultima regla por lambda
             |  {:RESULT = new ArrayList<NodoSentencia>(); :}  */
             ;

sentencia ::=  
      asignacion:sas 
      {: reglas.add("Regla N°15: sentencia -> asignacion");
         RESULT = sas;:}
    | iteracion:sif  
      {: reglas.add("Regla N°16: sentencia -> iteracion");
         RESULT = sif; :}
    | seleccion:sic  {: RESULT = sic; :}
    ;

asignacion ::= ID:id OP_ASIGNACION expresion:e {: 
    RESULT= new NodoAsignacion(new NodoIdentificador(id), e); System.out.println("ID::=E");:};
asignacion ::= ID OP_ASIGNACION CONST_STR {: reglas.add("Regla N°23: asignacion -> ID OP_ASIGNACION CONST_STR"); :};

expresion ::= expresion:a OP_SUMA termino:b {: 
    RESULT = new NodoSuma(a,b);
    System.out.println("E + T");
    reglas.add("Regla N°24: expresion -> expresion OP_SUMA termino");
    :};
expresion ::= expresion:a OP_RESTA termino:b {: 
    RESULT = new NodoResta(a,b);
    System.out.println("E - T");
    reglas.add("Regla N°25: expresion -> expresion OP_RESTA termino"); :};
expresion ::= termino:a  {: 
    RESULT = a;
    System.out.println("E es T");
    reglas.add("Regla N°26: expresion -> termino ");:};

termino  ::= termino:a OP_MULTIPLICACION factor:b  {:
    RESULT = new NodoMultiplicacion(a, b);
    reglas.add("Regla N°27: termino -> termino OP_MULTIPLICACION factor ");
    System.out.println("T = T*F");:};
termino  ::= termino:a OP_DIVISION factor:b  {: 
    RESULT = new NodoDivision(a, b);
    System.out.println("T = T/F");
    reglas.add("Regla N°28: termino -> termino OP_DIVISION factor ");:};
termino  ::= factor:a  {:
    RESULT = a;
    System.out.println("T es F");
    reglas.add("Regla N°29: termino -> factor ");
    :};


factor   ::= PARENTESIS_ABRE expresion PARENTESIS_CIERRA  {: reglas.add("Regla N°30: factor -> PARENTESIS_ABRE expresion PARENTESIS_CIERRA "); :};

factor   ::= ID:id {:
    reglas.add("Regla N°31: factor -> ID");
    RESULT = new NodoIdentificador(id);
    System.out.println("ID");:};
factor   ::= CONST_DOU {:reglas.add("Regla N°32: factor -> CONST_DOU"); :};
factor   ::= CONST_BIN {: reglas.add("Regla N°33: factor -> CONST_BIN"); :};
factor   ::= CONST_INTEGER:cte {:
    reglas.add("Regla N°34: factor -> CONST_INTEGER");
    RESULT =new NodoConstante(Integer.parseInt(cte));
    System.out.println("cte");:};
factor   ::= funcioncontarprimos {: reglas.add("Regla N°35: factor -> funcioncontarprimos"); :};




iteracion ::= WHILE condicion LLAVE_ABRE codigo LLAVE_CIERRA {: reglas.add("Regla N°36: iteracion -> WHILE condicion LLAVE_ABRE codigo LLAVE_CIERRA "); :};





seleccion ::= IF condicion:c THEN sentencias:st ELSE sentencias:se ENDIF {:
    reglas.add("Regla N°38: seleccion -> IF condicion THEN sentencias ELSE sentencias ENDIF");
    RESULT= new NodoIf(c, st, se);
    System.out.println("IF c THEN st ELSE se ENDIF");
    :};




condicion ::= comparacion:c {:
    reglas.add("Regla N°39: condicion -> comparacion");
    RESULT = c;
    :};
condicion ::= comparacion OP_AND comparacion {:
    reglas.add("Regla N°40: condicion -> comparacion OP_AND comparacion");
    :};
condicion ::= comparacion OP_OR comparacion {: 
    reglas.add("Regla N°41: condicion -> comparacion OP_OR comparacion");
    :};


comparacion ::= PARENTESIS_ABRE  expresion:e1 OP_IGUAL:c expresion:e2 PARENTESIS_CIERRA {:
  reglas.add("Regla N°42: comparacion -> PARENTESIS_ABRE  expresion == expresion PARENTESIS_CIERRA "); 
  RESULT = new NodoComparacion(c, e1, e2); 
  System.out.println("E1 == E2");
  :};
comparacion ::= OP_NOT comparacion  {: reglas.add("Regla N°43: comparacion -> OP_NOT comparacion  "); :};


comparador ::= OP_MENOR {: reglas.add("Regla N°44: comparador -> OP_MENOR"); :};
comparador ::= OP_MAYOR {: reglas.add("Regla N°45: comparador -> OP_MAYOR"); :};
comparador ::= OP_MAYOR_IGUAL {: reglas.add("Regla N°46: comparador -> OP_MAYOR_IGUAL"); :};
comparador ::= OP_MENOR_IGUAL {: reglas.add("Regla N°47: comparador -> OP_MENOR_IGUAL"); :};
comparador ::= OP_IGUAL:op {:
  reglas.add("Regla N°48: comparador -> OP_IGUAL");
  //RESULT = op;
  System.out.println("==");
  :};
comparador ::= OP_DISTINTO {: reglas.add("Regla N°49: comparador -> OP_DISTINTO "); :};


salida ::= WRITE ID {: reglas.add("Regla N°50: salida -> WRITE ID"); :};
salida ::= WRITE CONST_STR {: reglas.add("Regla N°51: salida -> WRITE CONST_STR"); :};




funcioncontarprimos ::= CONTAR_PRIMOS PARENTESIS_ABRE CORCHETE_ABRE parametros CORCHETE_CIERRA PARENTESIS_CIERRA {: reglas.add("Regla N°52: funcioncontarprimos ->  CONTAR_PRIMOS PARENTESIS_ABRE CORCHETE_ABRE parametros CORCHETE_CIERRA PARENTESIS_CIERRA"); :};
parametros ::= expresion {: reglas.add("Regla N°53: parametros -> expresion"); :};
parametros ::= expresion COMA parametros {: reglas.add("Regla N°54: parametros -> expresion COMA parametros"); :};